<!-- æ–‡ä»¶è·¯å¾„: motorcycle_game.html -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‘©æ‰˜ç‹‚é£™ - Motorcycle Rush</title>
    <style>
        /* å…¨å±€æ ·å¼è®¾ç½® */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB, #f0f0f0);
        }

        /* æ¸¸æˆç”»å¸ƒå®¹å™¨ */
        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* æ¸¸æˆç•Œé¢UIå±‚ */
        #gameUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* åˆ†æ•°æ˜¾ç¤ºé¢æ¿ */
        #scorePanel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 18px;
            pointer-events: auto;
        }

        .score-item {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }

        .score-label {
            font-weight: bold;
            margin-right: 10px;
            color: #FFD700;
        }

        /* ç”Ÿå‘½å€¼æ˜¾ç¤º */
        #healthBar {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .heart {
            width: 40px;
            height: 40px;
            background: red;
            clip-path: path('M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z');
            transform: scale(1.2);
        }

        .heart.lost {
            background: #333;
            opacity: 0.3;
        }

        /* æ¸¸æˆå¼€å§‹ç•Œé¢ */
        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            color: white;
        }

        .game-title {
            font-size: 64px;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #ff6600;
            background: linear-gradient(45deg, #ff6600, #ffcc00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: glow 2s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.5); }
        }

        /* æŒ‰é’®æ ·å¼ */
        .game-button {
            padding: 15px 40px;
            font-size: 24px;
            background: linear-gradient(45deg, #ff6600, #ff8800);
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(255, 102, 0, 0.4);
        }

        .game-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(255, 102, 0, 0.6);
        }

        /* æ¸¸æˆè¯´æ˜ */
        .instructions {
            margin-top: 30px;
            text-align: center;
            font-size: 18px;
            line-height: 1.8;
        }

        .instruction-item {
            margin: 10px 0;
        }

        /* ç‰¹æ•ˆæç¤º */
        #effectNotification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        /* éšè—ç±» */
        .hidden {
            display: none !important;
        }

        /* æŠ¤ç›¾æ¿€æ´»æç¤º */
        #shieldIndicator {
            position: absolute;
            top: 120px;
            right: 20px;
            background: rgba(0, 150, 255, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            font-weight: bold;
            display: none;
        }
    </style>
</head>
<body>
    <!-- æ¸¸æˆå®¹å™¨ -->
    <div id="gameContainer"></div>
    
    <!-- æ¸¸æˆUIå±‚ -->
    <div id="gameUI">
        <!-- åˆ†æ•°é¢æ¿ -->
        <div id="scorePanel">
            <div class="score-item">
                <span class="score-label">è·ç¦»:</span>
                <span id="distance">0</span> ç±³
            </div>
            <div class="score-item">
                <span class="score-label">é‡‘å¸:</span>
                <span id="coins">0</span>
            </div>
            <div class="score-item">
                <span class="score-label">é€Ÿåº¦:</span>
                <span id="speed">0</span> km/h
            </div>
        </div>

        <!-- ç”Ÿå‘½å€¼æ˜¾ç¤º -->
        <div id="healthBar">
            <div class="heart" data-heart="1"></div>
            <div class="heart" data-heart="2"></div>
            <div class="heart" data-heart="3"></div>
        </div>

        <!-- æŠ¤ç›¾æŒ‡ç¤ºå™¨ -->
        <div id="shieldIndicator">æŠ¤ç›¾æ¿€æ´»ä¸­</div>

        <!-- ç‰¹æ•ˆé€šçŸ¥ -->
        <div id="effectNotification"></div>

        <!-- å¼€å§‹ç•Œé¢ -->
        <div id="startScreen">
            <h1 class="game-title">ğŸï¸ æ‘©æ‰˜ç‹‚é£™ ğŸï¸</h1>
            <button class="game-button" onclick="startGame()">å¼€å§‹æ¸¸æˆ</button>
            <div class="instructions">
                <div class="instruction-item">â¬…ï¸ â¡ï¸ æ–¹å‘é”®æ§åˆ¶å·¦å³ç§»åŠ¨</div>
                <div class="instruction-item">ğŸª™ æ”¶é›†é‡‘å¸è·å¾—åˆ†æ•°</div>
                <div class="instruction-item">âš¡ åŠ é€Ÿé“å…·æå‡é€Ÿåº¦</div>
                <div class="instruction-item">ğŸ›¡ï¸ æŠ¤ç›¾ä¿æŠ¤ä½ å…å—ä¼¤å®³</div>
                <div class="instruction-item">â¤ï¸ çˆ±å¿ƒé“å…·æ¢å¤ç”Ÿå‘½å€¼</div>
                <div class="instruction-item">ğŸš— èº²é¿è½¦è¾†ï¼Œä¿æŒç”Ÿå‘½å€¼</div>
                <div class="instruction-item">ğŸŒ“ ä½“éªŒæ˜¼å¤œäº¤æ›¿çš„è§†è§‰æ•ˆæœ</div>
            </div>
        </div>

        <!-- æ¸¸æˆç»“æŸç•Œé¢ -->
        <div id="gameOverScreen" class="hidden">
            <h1 class="game-title">æ¸¸æˆç»“æŸ</h1>
            <div style="font-size: 32px; margin: 20px 0;">
                <p>æœ€ç»ˆè·ç¦»: <span id="finalDistance">0</span> ç±³</p>
                <p>æ”¶é›†é‡‘å¸: <span id="finalCoins">0</span></p>
                <p>æœ€é«˜é€Ÿåº¦: <span id="finalSpeed">0</span> km/h</p>
            </div>
            <button class="game-button" onclick="restartGame()">é‡æ–°å¼€å§‹</button>
        </div>
    </div>

    <!-- Three.jsåº“å¼•å…¥ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // ============ æ¸¸æˆæ ¸å¿ƒå˜é‡åˆå§‹åŒ– ============
        let scene, camera, renderer;
        let player; // ç©å®¶æ‘©æ‰˜è½¦
        let road; // é“è·¯å¯¹è±¡
        let obstacles = []; // éšœç¢ç‰©æ•°ç»„
        let coins = []; // é‡‘å¸æ•°ç»„
        let powerups = []; // é“å…·æ•°ç»„
        let gameRunning = false;
        let gameSpeed = 0.3; // æ¸¸æˆåˆå§‹é€Ÿåº¦
        let lanes = [-3, 0, 3]; // ä¸‰æ¡è½¦é“çš„Xåæ ‡
        let currentLane = 1; // å½“å‰è½¦é“ç´¢å¼•ï¼ˆä¸­é—´ï¼‰
        let score = 0; // åˆ†æ•°
        let distance = 0; // è¡Œé©¶è·ç¦»
        let health = 3; // ç”Ÿå‘½å€¼
        let coinCount = 0; // é‡‘å¸æ•°é‡
        let shieldActive = false; // æŠ¤ç›¾çŠ¶æ€
        let speedBoostActive = false; // åŠ é€ŸçŠ¶æ€
        let dayNightCycle = 0; // æ˜¼å¤œå¾ªç¯è®¡æ—¶å™¨
        let lastDifficultyStep = 0; // ?????????

        // ============ é”®ç›˜æ§åˆ¶çŠ¶æ€ ============
        const keys = {
            left: false,
            right: false
        };

        // ============ Three.jsåœºæ™¯åˆå§‹åŒ– ============
        function initThree() {
            try {
                // æ£€æŸ¥WebGLæ”¯æŒ
                if (!window.WebGLRenderingContext) {
                    throw new Error('WebGL not supported in this browser');
                }

                // åˆ›å»ºåœºæ™¯
                scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0x87CEEB, 10, 80); // æ·»åŠ é›¾æ•ˆå¢åŠ è·ç¦»æ„Ÿ

                // åˆ›å»ºé€è§†ç›¸æœº
                camera = new THREE.PerspectiveCamera(
                    75, // è§†é‡è§’åº¦
                    window.innerWidth / window.innerHeight, // å®½é«˜æ¯”
                    0.1, // è¿‘è£å‰ªé¢
                    1000 // è¿œè£å‰ªé¢
                );
                camera.position.set(0, 8, 12); // ç›¸æœºä½ç½®
                camera.lookAt(0, 0, -10); // ç›¸æœºæœå‘

                // åˆ›å»ºWebGLæ¸²æŸ“å™¨
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true; // å¯ç”¨é˜´å½±
                renderer.setPixelRatio(window.devicePixelRatio || 1); // é€‚é…é«˜åˆ†å±

                const gameContainer = document.getElementById('gameContainer');
                if (!gameContainer) {
                    throw new Error('Game container not found');
                }

                gameContainer.appendChild(renderer.domElement);

                // æ·»åŠ ç¯å¢ƒå…‰å’Œæ–¹å‘å…‰
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);

                // å“åº”çª—å£å¤§å°å˜åŒ–
                window.addEventListener('resize', onWindowResize);

            } catch (error) {
                console.error('Three.js initialization failed:', error);
                const gameContainer = document.getElementById('gameContainer');
                if (gameContainer) {
                    gameContainer.innerHTML = `<div style="color: white; text-align: center; padding: 50px;">
                        <h2>æ¸¸æˆåŠ è½½å¤±è´¥</h2>
                        <p>é”™è¯¯: ${error.message}</p>
                        <p>è¯·ç¡®ä¿æ‚¨çš„æµè§ˆå™¨æ”¯æŒWebGL</p>
                    </div>`;
                }
            }
        }

        // ============ åˆ›å»ºé“è·¯ ============
        function createRoad() {
            const roadGroup = new THREE.Group();

            // é“è·¯ä¸»ä½“
            const roadGeometry = new THREE.PlaneGeometry(12, 100);
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.8
            });
            const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
            roadMesh.rotation.x = -Math.PI / 2;
            roadMesh.receiveShadow = true;
            roadGroup.add(roadMesh);

            // é“è·¯åˆ†éš”çº¿
            for (let i = 0; i < 20; i++) {
                const lineGeometry = new THREE.BoxGeometry(0.3, 0.1, 3);
                const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.position.set(-3, 0.05, -i * 5);
                roadGroup.add(line);

                const line2 = line.clone();
                line2.position.x = 3;
                roadGroup.add(line2);
            }

            // è·¯è¾¹è‰åœ°
            const grassGeometry = new THREE.PlaneGeometry(50, 100);
            const grassMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            
            const grassLeft = new THREE.Mesh(grassGeometry, grassMaterial);
            grassLeft.rotation.x = -Math.PI / 2;
            grassLeft.position.x = -31;
            grassLeft.receiveShadow = true;
            roadGroup.add(grassLeft);

            const grassRight = grassLeft.clone();
            grassRight.position.x = 31;
            roadGroup.add(grassRight);

            scene.add(roadGroup);
            road = roadGroup;
        }

        // ============ åˆ›å»ºç©å®¶æ‘©æ‰˜è½¦ ============
        function createPlayer() {
            const playerGroup = new THREE.Group();

            // æ‘©æ‰˜è½¦è½¦èº«
            const bodyGeometry = new THREE.BoxGeometry(1, 0.6, 2);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.8;
            body.castShadow = true;
            playerGroup.add(body);

            // è½¦å¤´
            const headGeometry = new THREE.ConeGeometry(0.5, 0.8, 4);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xCC0000 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.rotation.x = Math.PI / 2;
            head.position.set(0, 0.8, -1.4);
            playerGroup.add(head);

            // è½¦è½®
            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            
            const wheelFront = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheelFront.rotation.z = Math.PI / 2;
            wheelFront.position.set(0, 0.4, -1);
            wheelFront.castShadow = true;
            playerGroup.add(wheelFront);

            const wheelBack = wheelFront.clone();
            wheelBack.position.z = 1;
            playerGroup.add(wheelBack);

            // é©¾é©¶å‘˜
            const driverGeometry = new THREE.SphereGeometry(0.4);
            const driverMaterial = new THREE.MeshStandardMaterial({ color: 0xFFCC99 });
            const driver = new THREE.Mesh(driverGeometry, driverMaterial);
            driver.position.set(0, 1.5, 0);
            playerGroup.add(driver);

            playerGroup.position.set(lanes[currentLane], 0, 5);
            scene.add(playerGroup);
            player = playerGroup;
        }

        // ============ åˆ›å»ºéšœç¢è½¦è¾† ============
        function createObstacle(lane) {
            const obstacleGroup = new THREE.Group();

            // éšæœºè½¦è¾†é¢œè‰²
            const colors = [0x0000FF, 0x00FF00, 0xFFFF00, 0xFF00FF, 0x00FFFF];
            const color = colors[Math.floor(Math.random() * colors.length)];

            // è½¦èº«
            const bodyGeometry = new THREE.BoxGeometry(1.5, 0.8, 3);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.8;
            body.castShadow = true;
            obstacleGroup.add(body);

            // è½¦é¡¶
            const roofGeometry = new THREE.BoxGeometry(1.4, 0.6, 1.5);
            const roof = new THREE.Mesh(roofGeometry, bodyMaterial);
            roof.position.set(0, 1.4, -0.3);
            obstacleGroup.add(roof);

            // è½¦è½®
            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            
            const positions = [
                [-0.9, 0.4, -1.2],
                [0.9, 0.4, -1.2],
                [-0.9, 0.4, 1.2],
                [0.9, 0.4, 1.2]
            ];

            positions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(...pos);
                obstacleGroup.add(wheel);
            });

            obstacleGroup.position.set(lanes[lane], 0, -50);
            scene.add(obstacleGroup);
            obstacles.push(obstacleGroup);
        }

        // ============ åˆ›å»ºé‡‘å¸ ============
        function createCoin(lane) {
            const coinGroup = new THREE.Group();

            // é‡‘å¸åœ†ç›˜
            const coinGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 16);
            const coinMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700,
                emissive: 0xFFD700,
                emissiveIntensity: 0.5
            });
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
            coin.rotation.x = Math.PI / 2;
            coinGroup.add(coin);

            coinGroup.position.set(lanes[lane], 1.5, -50);
            coinGroup.userData.rotation = 0; // ç”¨äºæ—‹è½¬åŠ¨ç”»
            scene.add(coinGroup);
            coins.push(coinGroup);
        }

        // ============ åˆ›å»ºé“å…·ï¼ˆåŠ é€Ÿã€æŠ¤ç›¾ã€çˆ±å¿ƒï¼‰============
        function createPowerup(lane, type) {
            const powerupGroup = new THREE.Group();

            if (type === 'speed') {
                // åŠ é€Ÿé“å…·ï¼ˆé—ªç”µå½¢çŠ¶ï¼‰
                const geometry = new THREE.ConeGeometry(0.5, 1.5, 4);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFF00,
                    emissive: 0xFFFF00,
                    emissiveIntensity: 0.6
                });
                const mesh = new THREE.Mesh(geometry, material);
                powerupGroup.add(mesh);
            } else if (type === 'shield') {
                // æŠ¤ç›¾é“å…·ï¼ˆçƒå½¢ï¼‰
                const geometry = new THREE.SphereGeometry(0.6, 16, 16);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0x00AAFF,
                    emissive: 0x00AAFF,
                    emissiveIntensity: 0.6,
                    transparent: true,
                    opacity: 0.7
                });
                const mesh = new THREE.Mesh(geometry, material);
                powerupGroup.add(mesh);
            } else if (type === 'health') {
                // çˆ±å¿ƒå›è¡€é“å…·
                const geometry = new THREE.SphereGeometry(0.5, 16, 16);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0xFF1493,
                    emissive: 0xFF1493,
                    emissiveIntensity: 0.6
                });
                const mesh = new THREE.Mesh(geometry, material);
                // æ·»åŠ ä¸€ä¸ªå°çƒä½œä¸ºçˆ±å¿ƒé¡¶éƒ¨è£…é¥°
                const topGeometry = new THREE.SphereGeometry(0.25, 8, 8);
                const topMesh1 = new THREE.Mesh(topGeometry, material);
                topMesh1.position.set(-0.2, 0.35, 0);
                const topMesh2 = new THREE.Mesh(topGeometry, material);
                topMesh2.position.set(0.2, 0.35, 0);
                powerupGroup.add(mesh);
                powerupGroup.add(topMesh1);
                powerupGroup.add(topMesh2);
            }

            powerupGroup.position.set(lanes[lane], 1.5, -50);
            powerupGroup.userData.type = type;
            powerupGroup.userData.rotation = 0;
            scene.add(powerupGroup);
            powerups.push(powerupGroup);
        }

        // ============ ç”Ÿæˆæ¸¸æˆå¯¹è±¡ ============
        function spawnObjects() {
            if (!gameRunning) return;

            // è®°å½•æœ¬æ¬¡ç”Ÿæˆå·²å ç”¨çš„è½¦é“
            const usedLanes = new Set();

            // æ ¹æ®éš¾åº¦è°ƒæ•´éšœç¢ç‰©æ•°é‡ï¼ˆ1-2ä¸ªï¼‰
            const obstacleCount = distance > 2000 ? (Math.random() < 0.4 ? 2 : 1) : 1;
            
            // ç”Ÿæˆéšœç¢ç‰©
            for (let o = 0; o < obstacleCount && usedLanes.size < 2; o++) {
                if (Math.random() < 0.6) {
                    const availableLanes = [0, 1, 2].filter(l => !usedLanes.has(l));
                    if (availableLanes.length > 0) {
                        const lane = availableLanes[Math.floor(Math.random() * availableLanes.length)];
                        createObstacle(lane);
                        usedLanes.add(lane);
                    }
                }
            }

            // éšæœºç”Ÿæˆé‡‘å¸ï¼ˆå¯ä»¥ç”Ÿæˆå¤šä¸ªï¼‰ï¼Œé¿å¼€å·²æœ‰éšœç¢ç‰©çš„è½¦é“
            const coinCount = Math.random() < 0.5 ? 2 : 1;
            for (let c = 0; c < coinCount; c++) {
                if (Math.random() < 0.7) {
                    const availableLanes = [0, 1, 2].filter(l => !usedLanes.has(l));
                    if (availableLanes.length > 0) {
                        const lane = availableLanes[Math.floor(Math.random() * availableLanes.length)];
                        createCoin(lane);
                        usedLanes.add(lane);
                    }
                }
            }

            // éšæœºç”Ÿæˆé“å…·ï¼ˆæ¦‚ç‡25%ï¼‰ï¼Œé¿å¼€å·²å ç”¨çš„è½¦é“
            if (Math.random() < 0.25) {
                const availableLanes = [0, 1, 2].filter(l => !usedLanes.has(l));
                if (availableLanes.length > 0) {
                    const lane = availableLanes[Math.floor(Math.random() * availableLanes.length)];
                    // é“å…·ç±»å‹ï¼šåŠ é€Ÿ40%ï¼ŒæŠ¤ç›¾40%ï¼Œçˆ±å¿ƒ20%ï¼ˆçˆ±å¿ƒæ›´ç¨€æœ‰ï¼‰
                    const rand = Math.random();
                    let type;
                    if (rand < 0.4) type = 'speed';
                    else if (rand < 0.8) type = 'shield';
                    else type = 'health';
                    createPowerup(lane, type);
                }
            }
        }

        // ============ é”®ç›˜äº‹ä»¶ç›‘å¬ ============
        function initControls() {
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') keys.left = true;
                if (e.key === 'ArrowRight') keys.right = true;
            });

            document.addEventListener('keyup', (e) => {
                if (e.key === 'ArrowLeft') keys.left = false;
                if (e.key === 'ArrowRight') keys.right = false;
            });
        }

        // ============ ç©å®¶ç§»åŠ¨é€»è¾‘ ============
        function updatePlayer() {
            // å·¦ç§»
            if (keys.left && currentLane > 0) {
                currentLane--;
                keys.left = false;
            }
            // å³ç§»
            if (keys.right && currentLane < 2) {
                currentLane++;
                keys.right = false;
            }

            // å¹³æ»‘ç§»åŠ¨åˆ°ç›®æ ‡è½¦é“
            const targetX = lanes[currentLane];
            player.position.x += (targetX - player.position.x) * 0.2;

            // æ·»åŠ è½»å¾®çš„å·¦å³å€¾æ–œæ•ˆæœ
            player.rotation.z = (targetX - player.position.x) * 0.3;
        }

        // ============ æ›´æ–°æ‰€æœ‰æ¸¸æˆå¯¹è±¡ ============
        function updateObjects() {
            const currentSpeed = speedBoostActive ? gameSpeed * 1.8 : gameSpeed;
            let tookDamageThisFrame = false;

            // ?????
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].position.z += currentSpeed;

                // ??????????
                if (obstacles[i].position.z > 10) {
                    disposeObject(obstacles[i]);
                    obstacles.splice(i, 1);
                    continue;
                }

                // ????
                if (checkCollision(player, obstacles[i])) {
                    if (shieldActive) {
                        // ??????????????
                        disposeObject(obstacles[i]);
                        obstacles.splice(i, 1);
                        showNotification('????!');
                    } else {
                        // ?????
                        health--;
                        tookDamageThisFrame = true;
                        updateHealth();
                        disposeObject(obstacles[i]);
                        obstacles.splice(i, 1);
                        showNotification('??! -1??');

                        // ??????????
                        if (health <= 0) {
                            gameOver();
                            break;
                        }
                    }
                }
            }

            // ????
            for (let i = coins.length - 1; i >= 0; i--) {
                coins[i].position.z += currentSpeed;
                coins[i].userData.rotation += 0.05;
                coins[i].rotation.y = coins[i].userData.rotation;

                if (coins[i].position.z > 10) {
                    disposeObject(coins[i]);
                    coins.splice(i, 1);
                    continue;
                }

                if (!gameRunning) continue;

                // ??????
                if (checkCollision(player, coins[i])) {
                    if (tookDamageThisFrame) {
                        disposeObject(coins[i]);
                        coins.splice(i, 1);
                        continue;
                    }

                    coinCount += 10;
                    score += 100;
                    updateScore();
                    disposeObject(coins[i]);
                    coins.splice(i, 1);
                    showNotification('+10 ??');
                }
            }

            // ????
            for (let i = powerups.length - 1; i >= 0; i--) {
                powerups[i].position.z += currentSpeed;
                powerups[i].userData.rotation += 0.08;
                powerups[i].rotation.y = powerups[i].userData.rotation;

                if (powerups[i].position.z > 10) {
                    disposeObject(powerups[i]);
                    powerups.splice(i, 1);
                    continue;
                }

                if (!gameRunning) continue;

                // ??????
                if (checkCollision(player, powerups[i])) {
                    const type = powerups[i].userData.type;

                    if (tookDamageThisFrame) {
                        disposeObject(powerups[i]);
                        powerups.splice(i, 1);
                        continue;
                    }

                    if (type === 'speed') {
                        activateSpeedBoost();
                    } else if (type === 'shield') {
                        activateShield();
                    } else if (type === 'health') {
                        activateHealth();
                    }

                    disposeObject(powerups[i]);
                    powerups.splice(i, 1);
                }
            }

            // æ›´æ–°é“è·¯åˆ†éš”çº¿
            road.children.forEach(child => {
                if (child.geometry && child.geometry.type === 'BoxGeometry') {
                    child.position.z += currentSpeed;
                    if (child.position.z > 10) {
                        child.position.z -= 100;
                    }
                }
            });
        }

        function disposeObject(obj) {
            if (!obj) return;

            // é€’å½’æ¸…ç†å­å¯¹è±¡
            obj.traverse((child) => {
                if (child.geometry) {
                    child.geometry.dispose();
                }
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(material => material.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            });

            if (obj.parent) {
                obj.parent.remove(obj);
            }
        }

        // ============ ç¢°æ’æ£€æµ‹ï¼ˆæ”¹è¿›çš„AABBåŒ…å›´ç›’æ£€æµ‹ï¼‰============
        function checkCollision(obj1, obj2) {
            // è·å–å¯¹è±¡çš„è¾¹ç•Œæ¡†
            const box1 = new THREE.Box3().setFromObject(obj1);
            const box2 = new THREE.Box3().setFromObject(obj2);

            // æ£€æµ‹è¾¹ç•Œæ¡†æ˜¯å¦ç›¸äº¤
            return box1.intersectsBox(box2);
        }

        // ============ æ¿€æ´»åŠ é€Ÿé“å…· ============
        function activateSpeedBoost() {
            speedBoostActive = true;
            showNotification('âš¡ åŠ é€Ÿæ¿€æ´»!');
            setTimeout(() => {
                speedBoostActive = false;
            }, 5000); // æŒç»­5ç§’
        }

        // ============ æ¿€æ´»æŠ¤ç›¾é“å…· ============
        function activateShield() {
            shieldActive = true;
            document.getElementById('shieldIndicator').style.display = 'block';
            showNotification('ğŸ›¡ï¸ æŠ¤ç›¾æ¿€æ´»!');

            // æ·»åŠ æŠ¤ç›¾è§†è§‰æ•ˆæœ
            const shieldGeometry = new THREE.SphereGeometry(2, 16, 16);
            const shieldMaterial = new THREE.MeshStandardMaterial({
                color: 0x00AAFF,
                emissive: 0x00AAFF,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.3,
                wireframe: true
            });
            const shieldMesh = new THREE.Mesh(shieldGeometry, shieldMaterial);
            player.add(shieldMesh);

            setTimeout(() => {
                shieldActive = false;
                disposeObject(shieldMesh);
                document.getElementById('shieldIndicator').style.display = 'none';
            }, 8000); // æŒç»­8ç§’
        }

        // ======================
        function activateHealth() {
            if (health < 3) {
                health++;
                updateHealth();
                showNotification('â¤ï¸ +1 ç”Ÿå‘½!');
            } else {
                // æ»¡è¡€æ—¶ç»™é¢å¤–åˆ†æ•°
                score += 500;
                coinCount += 50;
                updateScore();
                showNotification('â¤ï¸ æ»¡è¡€! +50é‡‘å¸');
            }
        }

        // ============ æ˜¾ç¤ºç‰¹æ•ˆé€šçŸ¥ ============
        function showNotification(text) {
            const notification = document.getElementById('effectNotification');
            notification.textContent = text;
            notification.style.opacity = '1';
            setTimeout(() => {
                notification.style.opacity = '0';
            }, 1500);
        }

        // ============ æ›´æ–°åˆ†æ•°æ˜¾ç¤º ============
        function updateScore() {
            document.getElementById('distance').textContent = Math.floor(distance);
            document.getElementById('coins').textContent = coinCount;
            document.getElementById('speed').textContent = Math.floor(gameSpeed * 300);
        }

        // ============ æ›´æ–°ç”Ÿå‘½å€¼æ˜¾ç¤º ============
        function updateHealth() {
            for (let i = 1; i <= 3; i++) {
                const heart = document.querySelector(`[data-heart="${i}"]`);
                if (i > health) {
                    heart.classList.add('lost');
                } else {
                    heart.classList.remove('lost');
                }
            }
        }

        // ============ æ˜¼å¤œå¾ªç¯ç³»ç»Ÿ ============
        function updateDayNightCycle() {
            dayNightCycle += 0.001;
            
            // è®¡ç®—å¤©ç©ºé¢œè‰²ï¼ˆç™½å¤©è“è‰² -> å‚æ™šæ©™è‰² -> å¤œæ™šæ·±è“ï¼‰
            const cycle = Math.sin(dayNightCycle);
            let skyColor;
            
            if (cycle > 0) {
                // ç™½å¤©
                skyColor = new THREE.Color(0x87CEEB).lerp(new THREE.Color(0xFF6347), cycle);
            } else {
                // å¤œæ™š
                skyColor = new THREE.Color(0x87CEEB).lerp(new THREE.Color(0x191970), -cycle);
            }
            
            scene.background = skyColor;
            scene.fog.color = skyColor;
        }

        // ============ éš¾åº¦é€’å¢ç³»ç»Ÿï¼ˆä¼˜åŒ–æ›²çº¿ï¼‰============
        function increaseDifficulty() {
            const currentStep = Math.floor(distance / 30000000000000); // æ¯300ç±³æ£€æŸ¥ä¸€æ¬¡
            if (currentStep > lastDifficultyStep) {
                lastDifficultyStep = currentStep;
                
                // æ¸è¿›å¼éš¾åº¦æå‡ï¼Œå‰æœŸæ…¢åæœŸå¿«
                let speedIncrease;
                if (distance < 10000000000000000) {
                    speedIncrease = 0.008; // å‰1000ç±³ï¼šç¼“æ…¢æå‡
                } else if (distance < 30000000000000000) {
                    speedIncrease = 0.012; // 1000-3000ç±³ï¼šä¸­ç­‰æå‡
                } else if (distance < 50000000000000000) {
                    speedIncrease = 0.018; // 3000-5000ç±³ï¼šè¾ƒå¿«æå‡
                } else {
                    speedIncrease = 0.022; // 5000ç±³åï¼šå¿«é€Ÿæå‡
                }
                
                // é™åˆ¶æœ€å¤§é€Ÿåº¦
                if (gameSpeed < 0.75) {
                    gameSpeed += speedIncrease;
                    showNotification('ğŸ”¥ éš¾åº¦æå‡!');
                }
            }
        }

        // ============ æ¸¸æˆä¸»å¾ªç¯ ============
        let lastSpawnTime = 0;
        function animate() {
            requestAnimationFrame(animate);

            if (gameRunning) {
                updatePlayer();
                updateObjects();
                updateDayNightCycle();

                // è·ç¦»ç´¯åŠ 
                distance += gameSpeed * 10;
                score += Math.floor(gameSpeed);
                updateScore();
                increaseDifficulty();

                // å®šæœŸç”Ÿæˆæ–°å¯¹è±¡ï¼ˆé™ä½ç”Ÿæˆé¢‘ç‡æå‡æ€§èƒ½ï¼‰
                const currentTime = Date.now();
                const spawnInterval = Math.max(1500, 3000 - gameSpeed * 200); // æ ¹æ®é€Ÿåº¦è°ƒæ•´ç”Ÿæˆé—´éš”
                if (currentTime - lastSpawnTime > spawnInterval) {
                    spawnObjects();
                    lastSpawnTime = currentTime;
                }
            }

            renderer.render(scene, camera);
        }

        // ============ çª—å£å°ºå¯¸è°ƒæ•´ ============
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============ å¼€å§‹æ¸¸æˆ ============
        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            gameRunning = true;
            resetGame();
        }

        // ============ é‡ç½®æ¸¸æˆçŠ¶æ€ ============
        function resetGame() {
            // æ¸…é™¤æ‰€æœ‰å¯¹è±¡
            obstacles.forEach(obj => scene.remove(obj));
            coins.forEach(obj => scene.remove(obj));
            powerups.forEach(obj => scene.remove(obj));
            
            obstacles = [];
            coins = [];
            powerups = [];
            
            // é‡ç½®å˜é‡
            score = 0;
            distance = 0;
            health = 3;
            coinCount = 0;
            lastDifficultyStep = 0;
            gameSpeed = 0.2;
            currentLane = 1;
            shieldActive = false;
            speedBoostActive = false;
            
            // é‡ç½®ç©å®¶ä½ç½®
            player.position.set(lanes[currentLane], 0, 5);
            
            updateScore();
            updateHealth();
            document.getElementById('shieldIndicator').style.display = 'none';
        }

        // ============ æ¸¸æˆç»“æŸ ============
        function gameOver() {
            gameRunning = false;
            document.getElementById('finalDistance').textContent = Math.floor(distance);
            document.getElementById('finalCoins').textContent = coinCount;
            document.getElementById('finalSpeed').textContent = Math.floor(gameSpeed * 300);
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }

        // ============ é‡æ–°å¼€å§‹æ¸¸æˆ ============
        function restartGame() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            gameRunning = true;
            resetGame();
        }

        // ============ åˆå§‹åŒ–æ¸¸æˆ ============
        window.onload = function() {
            initThree();
            createRoad();
            createPlayer();
            initControls();
            animate();
        };
    </script>
</body>
</html>
